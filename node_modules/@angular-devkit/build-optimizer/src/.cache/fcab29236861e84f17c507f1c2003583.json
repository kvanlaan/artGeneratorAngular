{"remainingRequest":"/Users/kvanlaan/Documents/generator/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/kvanlaan/Documents/generator/node_modules/@firebase/messaging/dist/index.esm.js","dependencies":[{"path":"/Users/kvanlaan/Documents/generator/node_modules/@firebase/messaging/dist/index.esm.js","mtime":1529605675000},{"path":"/Users/kvanlaan/Documents/generator/node_modules/cache-loader/dist/cjs.js","mtime":1552774307191},{"path":"/Users/kvanlaan/Documents/generator/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { ErrorFactory, createSubscribe } from '@firebase/util';\nimport { __extends, __awaiter, __generator, __assign } from 'tslib';\nimport firebase from '@firebase/app';\n/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ERROR_CODES = {\n    AVAILABLE_IN_WINDOW: 'only-available-in-window',\n    AVAILABLE_IN_SW: 'only-available-in-sw',\n    SHOULD_BE_INHERITED: 'should-be-overriden',\n    BAD_SENDER_ID: 'bad-sender-id',\n    INCORRECT_GCM_SENDER_ID: 'incorrect-gcm-sender-id',\n    PERMISSION_DEFAULT: 'permission-default',\n    PERMISSION_BLOCKED: 'permission-blocked',\n    UNSUPPORTED_BROWSER: 'unsupported-browser',\n    NOTIFICATIONS_BLOCKED: 'notifications-blocked',\n    FAILED_DEFAULT_REGISTRATION: 'failed-serviceworker-registration',\n    SW_REGISTRATION_EXPECTED: 'sw-registration-expected',\n    GET_SUBSCRIPTION_FAILED: 'get-subscription-failed',\n    INVALID_SAVED_TOKEN: 'invalid-saved-token',\n    SW_REG_REDUNDANT: 'sw-reg-redundant',\n    TOKEN_SUBSCRIBE_FAILED: 'token-subscribe-failed',\n    TOKEN_SUBSCRIBE_NO_TOKEN: 'token-subscribe-no-token',\n    TOKEN_SUBSCRIBE_NO_PUSH_SET: 'token-subscribe-no-push-set',\n    TOKEN_UNSUBSCRIBE_FAILED: 'token-unsubscribe-failed',\n    TOKEN_UPDATE_FAILED: 'token-update-failed',\n    TOKEN_UPDATE_NO_TOKEN: 'token-update-no-token',\n    USE_SW_BEFORE_GET_TOKEN: 'use-sw-before-get-token',\n    INVALID_DELETE_TOKEN: 'invalid-delete-token',\n    DELETE_TOKEN_NOT_FOUND: 'delete-token-not-found',\n    DELETE_SCOPE_NOT_FOUND: 'delete-scope-not-found',\n    BG_HANDLER_FUNCTION_EXPECTED: 'bg-handler-function-expected',\n    NO_WINDOW_CLIENT_TO_MSG: 'no-window-client-to-msg',\n    UNABLE_TO_RESUBSCRIBE: 'unable-to-resubscribe',\n    NO_FCM_TOKEN_FOR_RESUBSCRIBE: 'no-fcm-token-for-resubscribe',\n    FAILED_TO_DELETE_TOKEN: 'failed-to-delete-token',\n    NO_SW_IN_REG: 'no-sw-in-reg',\n    BAD_SCOPE: 'bad-scope',\n    BAD_VAPID_KEY: 'bad-vapid-key',\n    BAD_SUBSCRIPTION: 'bad-subscription',\n    BAD_TOKEN: 'bad-token',\n    BAD_PUSH_SET: 'bad-push-set',\n    FAILED_DELETE_VAPID_KEY: 'failed-delete-vapid-key',\n    INVALID_PUBLIC_VAPID_KEY: 'invalid-public-vapid-key',\n    USE_PUBLIC_KEY_BEFORE_GET_TOKEN: 'use-public-key-before-get-token',\n    PUBLIC_KEY_DECRYPTION_FAILED: 'public-vapid-key-decryption-failed'\n};\nvar ERROR_MAP = (_a = {}, _a[ERROR_CODES.AVAILABLE_IN_WINDOW] = 'This method is available in a Window context.', _a[ERROR_CODES.AVAILABLE_IN_SW] = 'This method is available in a service worker ' + 'context.', _a[ERROR_CODES.SHOULD_BE_INHERITED] = 'This method should be overriden by ' + 'extended classes.', _a[ERROR_CODES.BAD_SENDER_ID] = \"Please ensure that 'messagingSenderId' is set \" +\n    'correctly in the options passed into firebase.initializeApp().', _a[ERROR_CODES.PERMISSION_DEFAULT] = 'The required permissions were not granted and ' + 'dismissed instead.', _a[ERROR_CODES.PERMISSION_BLOCKED] = 'The required permissions were not granted and ' + 'blocked instead.', _a[ERROR_CODES.UNSUPPORTED_BROWSER] = \"This browser doesn't support the API's \" +\n    'required to use the firebase SDK.', _a[ERROR_CODES.NOTIFICATIONS_BLOCKED] = 'Notifications have been blocked.', _a[ERROR_CODES.FAILED_DEFAULT_REGISTRATION] = 'We are unable to register the ' +\n    'default service worker. {$browserErrorMessage}', _a[ERROR_CODES.SW_REGISTRATION_EXPECTED] = 'A service worker registration was the ' + 'expected input.', _a[ERROR_CODES.GET_SUBSCRIPTION_FAILED] = 'There was an error when trying to get ' +\n    'any existing Push Subscriptions.', _a[ERROR_CODES.INVALID_SAVED_TOKEN] = 'Unable to access details of the saved token.', _a[ERROR_CODES.SW_REG_REDUNDANT] = 'The service worker being used for push was made ' + 'redundant.', _a[ERROR_CODES.TOKEN_SUBSCRIBE_FAILED] = 'A problem occured while subscribing the ' + 'user to FCM: {$message}', _a[ERROR_CODES.TOKEN_SUBSCRIBE_NO_TOKEN] = 'FCM returned no token when subscribing ' + 'the user to push.', _a[ERROR_CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET] = 'FCM returned an invalid response ' + 'when getting an FCM token.', _a[ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED] = 'A problem occured while unsubscribing the ' + 'user from FCM: {$message}', _a[ERROR_CODES.TOKEN_UPDATE_FAILED] = 'A problem occured while updating the ' + 'user from FCM: {$message}', _a[ERROR_CODES.TOKEN_UPDATE_NO_TOKEN] = 'FCM returned no token when updating ' + 'the user to push.', _a[ERROR_CODES.USE_SW_BEFORE_GET_TOKEN] = 'The useServiceWorker() method may only be called once and must be ' +\n    'called before calling getToken() to ensure your service worker is used.', _a[ERROR_CODES.INVALID_DELETE_TOKEN] = 'You must pass a valid token into ' +\n    'deleteToken(), i.e. the token from getToken().', _a[ERROR_CODES.DELETE_TOKEN_NOT_FOUND] = 'The deletion attempt for token could not ' +\n    'be performed as the token was not found.', _a[ERROR_CODES.DELETE_SCOPE_NOT_FOUND] = 'The deletion attempt for service worker ' +\n    'scope could not be performed as the scope was not found.', _a[ERROR_CODES.BG_HANDLER_FUNCTION_EXPECTED] = 'The input to ' + 'setBackgroundMessageHandler() must be a function.', _a[ERROR_CODES.NO_WINDOW_CLIENT_TO_MSG] = 'An attempt was made to message a ' + 'non-existant window client.', _a[ERROR_CODES.UNABLE_TO_RESUBSCRIBE] = 'There was an error while re-subscribing ' +\n    'the FCM token for push messaging. Will have to resubscribe the ' +\n    'user on next visit. {$message}', _a[ERROR_CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE] = 'Could not find an FCM token ' +\n    'and as a result, unable to resubscribe. Will have to resubscribe the ' +\n    'user on next visit.', _a[ERROR_CODES.FAILED_TO_DELETE_TOKEN] = 'Unable to delete the currently saved token.', _a[ERROR_CODES.NO_SW_IN_REG] = 'Even though the service worker registration was ' +\n    'successful, there was a problem accessing the service worker itself.', _a[ERROR_CODES.INCORRECT_GCM_SENDER_ID] = \"Please change your web app manifest's \" +\n    \"'gcm_sender_id' value to '103953800507' to use Firebase messaging.\", _a[ERROR_CODES.BAD_SCOPE] = 'The service worker scope must be a string with at ' +\n    'least one character.', _a[ERROR_CODES.BAD_VAPID_KEY] = 'The public VAPID key is not a Uint8Array with 65 bytes.', _a[ERROR_CODES.BAD_SUBSCRIPTION] = 'The subscription must be a valid ' + 'PushSubscription.', _a[ERROR_CODES.BAD_TOKEN] = 'The FCM Token used for storage / lookup was not ' +\n    'a valid token string.', _a[ERROR_CODES.BAD_PUSH_SET] = 'The FCM push set used for storage / lookup was not ' +\n    'not a valid push set string.', _a[ERROR_CODES.FAILED_DELETE_VAPID_KEY] = 'The VAPID key could not be deleted.', _a[ERROR_CODES.INVALID_PUBLIC_VAPID_KEY] = 'The public VAPID key must be a string.', _a[ERROR_CODES.PUBLIC_KEY_DECRYPTION_FAILED] = 'The public VAPID key did not equal ' + '65 bytes when decrypted.', _a);\nvar errorFactory = new ErrorFactory('messaging', 'Messaging', ERROR_MAP);\nvar _a;\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([\n    0x04,\n    0x33,\n    0x94,\n    0xf7,\n    0xdf,\n    0xa1,\n    0xeb,\n    0xb1,\n    0xdc,\n    0x03,\n    0xa2,\n    0x5e,\n    0x15,\n    0x71,\n    0xdb,\n    0x48,\n    0xd3,\n    0x2e,\n    0xed,\n    0xed,\n    0xb2,\n    0x34,\n    0xdb,\n    0xb7,\n    0x47,\n    0x3a,\n    0x0c,\n    0x8f,\n    0xc4,\n    0xcc,\n    0xe1,\n    0x6f,\n    0x3c,\n    0x8c,\n    0x84,\n    0xdf,\n    0xab,\n    0xb6,\n    0x66,\n    0x3e,\n    0xf2,\n    0x0c,\n    0xd4,\n    0x8b,\n    0xfe,\n    0xe3,\n    0xf9,\n    0x76,\n    0x2f,\n    0x14,\n    0x1c,\n    0x63,\n    0x08,\n    0x6a,\n    0x6f,\n    0x2d,\n    0xb1,\n    0x1a,\n    0x95,\n    0xb0,\n    0xce,\n    0x37,\n    0xc0,\n    0x9c,\n    0x6e\n]);\nvar ENDPOINT = 'https://fcm.googleapis.com';\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MessageParameter;\n(function (MessageParameter) {\n    MessageParameter[\"TYPE_OF_MSG\"] = \"firebase-messaging-msg-type\";\n    MessageParameter[\"DATA\"] = \"firebase-messaging-msg-data\";\n})(MessageParameter || (MessageParameter = {}));\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"PUSH_MSG_RECEIVED\"] = \"push-msg-received\";\n    MessageType[\"NOTIFICATION_CLICKED\"] = \"notification-clicked\";\n})(MessageType || (MessageType = {}));\n/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isArrayBufferEqual(a, b) {\n    if (a == null || b == null) {\n        return false;\n    }\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    var viewA = new DataView(a);\n    var viewB = new DataView(b);\n    for (var i = 0; i < a.byteLength; i++) {\n        if (viewA.getUint8(i) !== viewB.getUint8(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction toBase64(arrayBuffer) {\n    var uint8Version = new Uint8Array(arrayBuffer);\n    return btoa(String.fromCharCode.apply(null, uint8Version));\n}\nfunction arrayBufferToBase64(arrayBuffer) {\n    var base64String = toBase64(arrayBuffer);\n    return base64String\n        .replace(/=/g, '')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_');\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IidModel = /** @class */ /*@__PURE__*/ (function () {\n    function IidModel() {\n    }\n    IidModel.prototype.getToken = function (senderId, subscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var p256dh, auth, fcmSubscribeBody, applicationPubKey, headers, subscribeOptions, responseData, response, err_1, message;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        p256dh = arrayBufferToBase64(subscription.getKey('p256dh'));\n                        auth = arrayBufferToBase64(subscription.getKey('auth'));\n                        fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n                            (\"endpoint=\" + subscription.endpoint + \"&\") +\n                            (\"encryption_key=\" + p256dh + \"&\") +\n                            (\"encryption_auth=\" + auth);\n                        if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n                            applicationPubKey = arrayBufferToBase64(publicVapidKey);\n                            fcmSubscribeBody += \"&application_pub_key=\" + applicationPubKey;\n                        }\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        subscribeOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmSubscribeBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_1 = _a.sent();\n                        throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_FAILED);\n                    case 5:\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_FAILED, {\n                                message: message\n                            });\n                        }\n                        if (!responseData.token) {\n                            throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_NO_TOKEN);\n                        }\n                        if (!responseData.pushSet) {\n                            throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n                        }\n                        return [2 /*return*/, {\n                                token: responseData.token,\n                                pushSet: responseData.pushSet\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Update the underlying token details for fcmToken.\n     */\n    IidModel.prototype.updateToken = function (senderId, fcmToken, fcmPushSet, subscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var p256dh, auth, fcmUpdateBody, applicationPubKey, headers, updateOptions, responseData, response, err_2, message;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        p256dh = arrayBufferToBase64(subscription.getKey('p256dh'));\n                        auth = arrayBufferToBase64(subscription.getKey('auth'));\n                        fcmUpdateBody = \"push_set=\" + fcmPushSet + \"&\" +\n                            (\"token=\" + fcmToken + \"&\") +\n                            (\"authorized_entity=\" + senderId + \"&\") +\n                            (\"endpoint=\" + subscription.endpoint + \"&\") +\n                            (\"encryption_key=\" + p256dh + \"&\") +\n                            (\"encryption_auth=\" + auth);\n                        if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n                            applicationPubKey = arrayBufferToBase64(publicVapidKey);\n                            fcmUpdateBody += \"&application_pub_key=\" + applicationPubKey;\n                        }\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        updateOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmUpdateBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/subscribe', updateOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_2 = _a.sent();\n                        throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_FAILED);\n                    case 5:\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_FAILED, {\n                                message: message\n                            });\n                        }\n                        if (!responseData.token) {\n                            throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_NO_TOKEN);\n                        }\n                        return [2 /*return*/, responseData.token];\n                }\n            });\n        });\n    };\n    /**\n     * Given a fcmToken, pushSet and messagingSenderId, delete an FCM token.\n     */\n    IidModel.prototype.deleteToken = function (senderId, fcmToken, fcmPushSet) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fcmUnsubscribeBody, headers, unsubscribeOptions, response, responseData, message, err_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fcmUnsubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n                            (\"token=\" + fcmToken + \"&\") +\n                            (\"pushSet=\" + fcmPushSet);\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        unsubscribeOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmUnsubscribeBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/unsubscribe', unsubscribeOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED, {\n                                message: message\n                            });\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_3 = _a.sent();\n                        throw errorFactory.create(ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED);\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return IidModel;\n}());\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction base64ToArrayBuffer(base64String) {\n    var padding = '='.repeat((4 - base64String.length % 4) % 4);\n    var base64 = (base64String + padding)\n        .replace(/\\-/g, '+')\n        .replace(/_/g, '/');\n    var rawData = atob(base64);\n    var outputArray = new Uint8Array(rawData.length);\n    for (var i = 0; i < rawData.length; ++i) {\n        outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OLD_DB_NAME = 'undefined';\nvar OLD_OBJECT_STORE_NAME = 'fcm_token_object_Store';\nfunction handleDb(db) {\n    if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n        // We found a database with the name 'undefined', but our expected object\n        // store isn't defined.\n        return;\n    }\n    var transaction = db.transaction(OLD_OBJECT_STORE_NAME);\n    var objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);\n    var iidModel = new IidModel();\n    var openCursorRequest = objectStore.openCursor();\n    openCursorRequest.onerror = function (event) {\n        // NOOP - Nothing we can do.\n        console.warn('Unable to cleanup old IDB.', event);\n    };\n    openCursorRequest.onsuccess = function () {\n        var cursor = openCursorRequest.result;\n        if (cursor) {\n            // cursor.value contains the current record being iterated through\n            // this is where you'd do something with the result\n            var tokenDetails = cursor.value;\n            iidModel.deleteToken(tokenDetails.fcmSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet);\n            cursor.continue();\n        }\n        else {\n            db.close();\n            indexedDB.deleteDatabase(OLD_DB_NAME);\n        }\n    };\n}\nfunction cleanV1() {\n    var request = indexedDB.open(OLD_DB_NAME);\n    request.onerror = function (event) {\n        // NOOP - Nothing we can do.\n    };\n    request.onsuccess = function (event) {\n        var db = request.result;\n        handleDb(db);\n    };\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DbInterface = /** @class */ /*@__PURE__*/ (function () {\n    function DbInterface() {\n        this.dbPromise = null;\n    }\n    /** Gets record(s) from the objectStore that match the given key. */\n    DbInterface.prototype.get = function (key) {\n        return this.createTransaction(function (objectStore) { return objectStore.get(key); });\n    };\n    /** Gets record(s) from the objectStore that match the given index. */\n    DbInterface.prototype.getIndex = function (index, key) {\n        function runRequest(objectStore) {\n            var idbIndex = objectStore.index(index);\n            return idbIndex.get(key);\n        }\n        return this.createTransaction(runRequest);\n    };\n    /** Assigns or overwrites the record for the given value. */\n    // tslint:disable-next-line:no-any IndexedDB values are of type \"any\"\n    DbInterface.prototype.put = function (value) {\n        return this.createTransaction(function (objectStore) { return objectStore.put(value); }, 'readwrite');\n    };\n    /** Deletes record(s) from the objectStore that match the given key. */\n    DbInterface.prototype.delete = function (key) {\n        return this.createTransaction(function (objectStore) { return objectStore.delete(key); }, 'readwrite');\n    };\n    /**\n     * Close the currently open database.\n     */\n    DbInterface.prototype.closeDatabase = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var db;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.dbPromise)\n                            return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.dbPromise];\n                    case 1:\n                        db = _a.sent();\n                        db.close();\n                        this.dbPromise = null;\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Creates an IndexedDB Transaction and passes its objectStore to the\n     * runRequest function, which runs the database request.\n     *\n     * @return Promise that resolves with the result of the runRequest function\n     */\n    DbInterface.prototype.createTransaction = function (runRequest, mode) {\n        if (mode === void 0) {\n            mode = 'readonly';\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            var db, transaction, request, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getDb()];\n                    case 1:\n                        db = _a.sent();\n                        transaction = db.transaction(this.objectStoreName, mode);\n                        request = transaction.objectStore(this.objectStoreName);\n                        return [4 /*yield*/, promisify(runRequest(request))];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                transaction.oncomplete = function () {\n                                    resolve(result);\n                                };\n                                transaction.onerror = function () {\n                                    reject(transaction.error);\n                                };\n                            })];\n                }\n            });\n        });\n    };\n    /** Gets the cached db connection or opens a new one. */\n    DbInterface.prototype.getDb = function () {\n        var _this = this;\n        if (!this.dbPromise) {\n            this.dbPromise = new Promise(function (resolve, reject) {\n                var request = indexedDB.open(_this.dbName, _this.dbVersion);\n                request.onsuccess = function () {\n                    resolve(request.result);\n                };\n                request.onerror = function () {\n                    _this.dbPromise = null;\n                    reject(request.error);\n                };\n                request.onupgradeneeded = function (event) { return _this.onDbUpgrade(request, event); };\n            });\n        }\n        return this.dbPromise;\n    };\n    return DbInterface;\n}());\n/** Promisifies an IDBRequest. Resolves with the IDBRequest's result. */\nfunction promisify(request) {\n    return new Promise(function (resolve, reject) {\n        request.onsuccess = function () {\n            resolve(request.result);\n        };\n        request.onerror = function () {\n            reject(request.error);\n        };\n    });\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TokenDetailsModel = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(TokenDetailsModel, _super);\n    function TokenDetailsModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dbName = 'fcm_token_details_db';\n        _this.dbVersion = 3;\n        _this.objectStoreName = 'fcm_token_object_Store';\n        return _this;\n    }\n    TokenDetailsModel.prototype.onDbUpgrade = function (request, event) {\n        var db = request.result;\n        // Lack of 'break' statements is intentional.\n        switch (event.oldVersion) {\n            case 0: {\n                // New IDB instance\n                var objectStore = db.createObjectStore(this.objectStoreName, {\n                    keyPath: 'swScope'\n                });\n                // Make sure the sender ID can be searched\n                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n                    unique: false\n                });\n                objectStore.createIndex('fcmToken', 'fcmToken', { unique: true });\n            }\n            case 1: {\n                // Prior to version 2, we were using either 'fcm_token_details_db'\n                // or 'undefined' as the database name due to bug in the SDK\n                // So remove the old tokens and databases.\n                cleanV1();\n            }\n            case 2: {\n                var objectStore = request.transaction.objectStore(this.objectStoreName);\n                var cursorRequest_1 = objectStore.openCursor();\n                cursorRequest_1.onsuccess = function () {\n                    var cursor = cursorRequest_1.result;\n                    if (cursor) {\n                        var value = cursor.value;\n                        var newValue = __assign({}, value);\n                        if (!value.createTime) {\n                            newValue.createTime = Date.now();\n                        }\n                        if (typeof value.vapidKey === 'string') {\n                            newValue.vapidKey = base64ToArrayBuffer(value.vapidKey);\n                        }\n                        if (typeof value.auth === 'string') {\n                            newValue.auth = base64ToArrayBuffer(value.auth).buffer;\n                        }\n                        if (typeof value.auth === 'string') {\n                            newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer;\n                        }\n                        cursor.update(newValue);\n                        cursor.continue();\n                    }\n                };\n            }\n        }\n    };\n    /**\n     * Given a token, this method will look up the details in indexedDB.\n     */\n    TokenDetailsModel.prototype.getTokenDetailsFromToken = function (fcmToken) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!fcmToken) {\n                    throw errorFactory.create(ERROR_CODES.BAD_TOKEN);\n                }\n                validateInputs({ fcmToken: fcmToken });\n                return [2 /*return*/, this.getIndex('fcmToken', fcmToken)];\n            });\n        });\n    };\n    /**\n     * Given a service worker scope, this method will look up the details in\n     * indexedDB.\n     * @return The details associated with that token.\n     */\n    TokenDetailsModel.prototype.getTokenDetailsFromSWScope = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!swScope) {\n                    throw errorFactory.create(ERROR_CODES.BAD_SCOPE);\n                }\n                validateInputs({ swScope: swScope });\n                return [2 /*return*/, this.get(swScope)];\n            });\n        });\n    };\n    /**\n     * Save the details for the fcm token for re-use at a later date.\n     * @param input A plain js object containing args to save.\n     */\n    TokenDetailsModel.prototype.saveTokenDetails = function (tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!tokenDetails.swScope) {\n                    throw errorFactory.create(ERROR_CODES.BAD_SCOPE);\n                }\n                if (!tokenDetails.vapidKey) {\n                    throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);\n                }\n                if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) {\n                    throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);\n                }\n                if (!tokenDetails.fcmSenderId) {\n                    throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);\n                }\n                if (!tokenDetails.fcmToken) {\n                    throw errorFactory.create(ERROR_CODES.BAD_TOKEN);\n                }\n                if (!tokenDetails.fcmPushSet) {\n                    throw errorFactory.create(ERROR_CODES.BAD_PUSH_SET);\n                }\n                validateInputs(tokenDetails);\n                return [2 /*return*/, this.put(tokenDetails)];\n            });\n        });\n    };\n    /**\n     * This method deletes details of the current FCM token.\n     * It's returning a promise in case we need to move to an async\n     * method for deleting at a later date.\n     *\n     * @return Resolves once the FCM token details have been deleted and returns\n     * the deleted details.\n     */\n    TokenDetailsModel.prototype.deleteToken = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof token !== 'string' || token.length === 0) {\n                            return [2 /*return*/, Promise.reject(errorFactory.create(ERROR_CODES.INVALID_DELETE_TOKEN))];\n                        }\n                        return [4 /*yield*/, this.getTokenDetailsFromToken(token)];\n                    case 1:\n                        details = _a.sent();\n                        if (!details) {\n                            throw errorFactory.create(ERROR_CODES.DELETE_TOKEN_NOT_FOUND);\n                        }\n                        return [4 /*yield*/, this.delete(details.swScope)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, details];\n                }\n            });\n        });\n    };\n    return TokenDetailsModel;\n}(DbInterface));\n/**\n * This method takes an object and will check for known arguments and\n * validate the input.\n * @return Promise that resolves if input is valid, rejects otherwise.\n */\nfunction validateInputs(input) {\n    if (input.fcmToken) {\n        if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) {\n            throw errorFactory.create(ERROR_CODES.BAD_TOKEN);\n        }\n    }\n    if (input.swScope) {\n        if (typeof input.swScope !== 'string' || input.swScope.length === 0) {\n            throw errorFactory.create(ERROR_CODES.BAD_SCOPE);\n        }\n    }\n    if (input.vapidKey) {\n        if (!(input.vapidKey instanceof Uint8Array) ||\n            input.vapidKey.length !== 65) {\n            throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);\n        }\n    }\n    if (input.endpoint) {\n        if (typeof input.endpoint !== 'string' || input.endpoint.length === 0) {\n            throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);\n        }\n    }\n    if (input.auth) {\n        if (!(input.auth instanceof ArrayBuffer)) {\n            throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);\n        }\n    }\n    if (input.p256dh) {\n        if (!(input.p256dh instanceof ArrayBuffer)) {\n            throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);\n        }\n    }\n    if (input.fcmSenderId) {\n        if (typeof input.fcmSenderId !== 'string' ||\n            input.fcmSenderId.length === 0) {\n            throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);\n        }\n    }\n    if (input.fcmPushSet) {\n        if (typeof input.fcmPushSet !== 'string' || input.fcmPushSet.length === 0) {\n            throw errorFactory.create(ERROR_CODES.BAD_PUSH_SET);\n        }\n    }\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nvar VapidDetailsModel = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(VapidDetailsModel, _super);\n    function VapidDetailsModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dbName = 'fcm_vapid_details_db';\n        _this.dbVersion = 1;\n        _this.objectStoreName = 'fcm_vapid_object_Store';\n        return _this;\n    }\n    VapidDetailsModel.prototype.onDbUpgrade = function (request) {\n        var db = request.result;\n        db.createObjectStore(this.objectStoreName, { keyPath: 'swScope' });\n    };\n    /**\n     * Given a service worker scope, this method will look up the vapid key\n     * in indexedDB.\n     */\n    VapidDetailsModel.prototype.getVapidFromSWScope = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof swScope !== 'string' || swScope.length === 0) {\n                            throw errorFactory.create(ERROR_CODES.BAD_SCOPE);\n                        }\n                        return [4 /*yield*/, this.get(swScope)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, result ? result.vapidKey : undefined];\n                }\n            });\n        });\n    };\n    /**\n     * Save a vapid key against a swScope for later date.\n     */\n    VapidDetailsModel.prototype.saveVapidDetails = function (swScope, vapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                if (typeof swScope !== 'string' || swScope.length === 0) {\n                    throw errorFactory.create(ERROR_CODES.BAD_SCOPE);\n                }\n                if (vapidKey === null || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n                    throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);\n                }\n                details = {\n                    swScope: swScope,\n                    vapidKey: vapidKey\n                };\n                return [2 /*return*/, this.put(details)];\n            });\n        });\n    };\n    /**\n     * This method deletes details of the current FCM VAPID key for a SW scope.\n     * Resolves once the scope/vapid details have been deleted and returns the\n     * deleted vapid key.\n     */\n    VapidDetailsModel.prototype.deleteVapidDetails = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var vapidKey;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getVapidFromSWScope(swScope)];\n                    case 1:\n                        vapidKey = _a.sent();\n                        if (!vapidKey) {\n                            throw errorFactory.create(ERROR_CODES.DELETE_SCOPE_NOT_FOUND);\n                        }\n                        return [4 /*yield*/, this.delete(swScope)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, vapidKey];\n                }\n            });\n        });\n    };\n    return VapidDetailsModel;\n}(DbInterface));\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\n// Database cache should be invalidated once a week.\nvar TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\nvar BaseController = /** @class */ /*@__PURE__*/ (function () {\n    /**\n     * An interface of the Messaging Service API\n     */\n    function BaseController(app) {\n        var _this = this;\n        if (!app.options[SENDER_ID_OPTION_NAME] ||\n            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);\n        }\n        this.messagingSenderId = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenDetailsModel = new TokenDetailsModel();\n        this.vapidDetailsModel = new VapidDetailsModel();\n        this.iidModel = new IidModel();\n        this.app = app;\n        this.INTERNAL = {\n            delete: function () { return _this.delete(); }\n        };\n    }\n    /**\n     * @export\n     */\n    BaseController.prototype.getToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var currentPermission, swReg, publicVapidKey, pushSubscription, tokenDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        currentPermission = this.getNotificationPermission_();\n                        if (currentPermission === 'denied') {\n                            throw errorFactory.create(ERROR_CODES.NOTIFICATIONS_BLOCKED);\n                        }\n                        else if (currentPermission !== 'granted') {\n                            // We must wait for permission to be granted\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        swReg = _a.sent();\n                        return [4 /*yield*/, this.getPublicVapidKey_()];\n                    case 2:\n                        publicVapidKey = _a.sent();\n                        return [4 /*yield*/, this.getPushSubscription(swReg, publicVapidKey)];\n                    case 3:\n                        pushSubscription = _a.sent();\n                        return [4 /*yield*/, this.tokenDetailsModel.getTokenDetailsFromSWScope(swReg.scope)];\n                    case 4:\n                        tokenDetails = _a.sent();\n                        if (tokenDetails) {\n                            return [2 /*return*/, this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                        }\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    /**\n     * manageExistingToken is triggered if there's an existing FCM token in the\n     * database and it can take 3 different actions:\n     * 1) Retrieve the existing FCM token from the database.\n     * 2) If VAPID details have changed: Delete the existing token and create a\n     * new one with the new VAPID key.\n     * 3) If the database cache is invalidated: Send a request to FCM to update\n     * the token, and to check if the token is still valid on FCM-side.\n     */\n    BaseController.prototype.manageExistingToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            var isTokenValid, now;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isTokenValid = isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);\n                        if (isTokenValid) {\n                            now = Date.now();\n                            if (now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS) {\n                                return [2 /*return*/, tokenDetails.fcmToken];\n                            }\n                            else {\n                                return [2 /*return*/, this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                            }\n                        }\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token from the FCM client and server\n                        // database. No need to unsubscribe from the Service Worker as we have a\n                        // good push subscription that we'd like to use in getNewToken.\n                        return [4 /*yield*/, this.deleteTokenFromDB(tokenDetails.fcmToken)];\n                    case 1:\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token from the FCM client and server\n                        // database. No need to unsubscribe from the Service Worker as we have a\n                        // good push subscription that we'd like to use in getNewToken.\n                        _a.sent();\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    BaseController.prototype.updateToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            var updatedToken, allDetails, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 6]);\n                        return [4 /*yield*/, this.iidModel.updateToken(this.messagingSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet, pushSubscription, publicVapidKey)];\n                    case 1:\n                        updatedToken = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            fcmSenderId: this.messagingSenderId,\n                            fcmToken: updatedToken,\n                            fcmPushSet: tokenDetails.fcmPushSet,\n                            createTime: Date.now(),\n                            endpoint: pushSubscription.endpoint,\n                            auth: pushSubscription.getKey('auth'),\n                            p256dh: pushSubscription.getKey('p256dh')\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, updatedToken];\n                    case 4:\n                        e_1 = _a.sent();\n                        return [4 /*yield*/, this.deleteToken(tokenDetails.fcmToken)];\n                    case 5:\n                        _a.sent();\n                        throw e_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseController.prototype.getNewToken = function (swReg, pushSubscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenDetails, allDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.iidModel.getToken(this.messagingSenderId, pushSubscription, publicVapidKey)];\n                    case 1:\n                        tokenDetails = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            fcmSenderId: this.messagingSenderId,\n                            fcmToken: tokenDetails.token,\n                            fcmPushSet: tokenDetails.pushSet,\n                            createTime: Date.now(),\n                            endpoint: pushSubscription.endpoint,\n                            auth: pushSubscription.getKey('auth'),\n                            p256dh: pushSubscription.getKey('p256dh')\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, tokenDetails.token];\n                }\n            });\n        });\n    };\n    /**\n     * This method deletes tokens that the token manager looks after,\n     * unsubscribes the token from FCM  and then unregisters the push\n     * subscription if it exists. It returns a promise that indicates\n     * whether or not the unsubscribe request was processed successfully.\n     */\n    BaseController.prototype.deleteToken = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var registration, pushSubscription;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Delete the token details from the database.\n                        return [4 /*yield*/, this.deleteTokenFromDB(token)];\n                    case 1:\n                        // Delete the token details from the database.\n                        _a.sent();\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 2:\n                        registration = _a.sent();\n                        if (!registration)\n                            return [3 /*break*/, 4];\n                        return [4 /*yield*/, registration.pushManager.getSubscription()];\n                    case 3:\n                        pushSubscription = _a.sent();\n                        if (pushSubscription) {\n                            return [2 /*return*/, pushSubscription.unsubscribe()];\n                        }\n                        _a.label = 4;\n                    case 4:\n                        // If there's no SW, consider it a success.\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    /**\n     * This method will delete the token from the client database, and make a\n     * call to FCM to remove it from the server DB. Does not temper with the\n     * push subscription.\n     */\n    BaseController.prototype.deleteTokenFromDB = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.tokenDetailsModel.deleteToken(token)];\n                    case 1:\n                        details = _a.sent();\n                        return [4 /*yield*/, this.iidModel.deleteToken(details.fcmSenderId, details.fcmToken, details.fcmPushSet)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Gets a PushSubscription for the current user.\n     */\n    BaseController.prototype.getPushSubscription = function (swRegistration, publicVapidKey) {\n        return swRegistration.pushManager.getSubscription().then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe({\n                userVisibleOnly: true,\n                applicationServerKey: publicVapidKey\n            });\n        });\n    };\n    //\n    // The following methods should only be available in the window.\n    //\n    BaseController.prototype.requestPermission = function () {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);\n    };\n    BaseController.prototype.useServiceWorker = function (registration) {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);\n    };\n    BaseController.prototype.usePublicVapidKey = function (b64PublicKey) {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);\n    };\n    BaseController.prototype.onMessage = function (nextOrObserver, error, completed) {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);\n    };\n    BaseController.prototype.onTokenRefresh = function (nextOrObserver, error, completed) {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);\n    };\n    //\n    // The following methods are used by the service worker only.\n    //\n    BaseController.prototype.setBackgroundMessageHandler = function (callback) {\n        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_SW);\n    };\n    //\n    // The following methods are used by the service themselves and not exposed\n    // publicly or not expected to be used by developers.\n    //\n    /**\n     * This method is required to adhere to the Firebase interface.\n     * It closes any currently open indexdb database connections.\n     */\n    BaseController.prototype.delete = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.tokenDetailsModel.closeDatabase(),\n                            this.vapidDetailsModel.closeDatabase()\n                        ])];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the current Notification Permission state.\n     */\n    BaseController.prototype.getNotificationPermission_ = function () {\n        // TODO: Remove the cast when this issue is fixed:\n        // https://github.com/Microsoft/TypeScript/issues/14701\n        // tslint:disable-next-line no-any\n        return Notification.permission;\n    };\n    BaseController.prototype.getTokenDetailsModel = function () {\n        return this.tokenDetailsModel;\n    };\n    BaseController.prototype.getVapidDetailsModel = function () {\n        return this.vapidDetailsModel;\n    };\n    // Visible for testing\n    // TODO: make protected\n    BaseController.prototype.getIidModel = function () {\n        return this.iidModel;\n    };\n    return BaseController;\n}());\n/**\n * Checks if the tokenDetails match the details provided in the clients.\n */\nfunction isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails) {\n    if (!tokenDetails.vapidKey ||\n        !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)) {\n        return false;\n    }\n    var isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;\n    var isAuthEqual = isArrayBufferEqual(pushSubscription.getKey('auth'), tokenDetails.auth);\n    var isP256dhEqual = isArrayBufferEqual(pushSubscription.getKey('p256dh'), tokenDetails.p256dh);\n    return isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar FCM_MSG = 'FCM_MSG';\nvar SwController = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(SwController, _super);\n    function SwController(app) {\n        var _this = _super.call(this, app) || this;\n        _this.bgMessageHandler = null;\n        self.addEventListener('push', function (e) {\n            _this.onPush(e);\n        });\n        self.addEventListener('pushsubscriptionchange', function (e) {\n            _this.onSubChange(e);\n        });\n        self.addEventListener('notificationclick', function (e) {\n            _this.onNotificationClick(e);\n        });\n        return _this;\n    }\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onPush = function (event) {\n        event.waitUntil(this.onPush_(event));\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onSubChange = function (event) {\n        event.waitUntil(this.onSubChange_(event));\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onNotificationClick = function (event) {\n        event.waitUntil(this.onNotificationClick_(event));\n    };\n    /**\n     * A handler for push events that shows notifications based on the content of\n     * the payload.\n     *\n     * The payload must be a JSON-encoded Object with a `notification` key. The\n     * value of the `notification` property will be used as the NotificationOptions\n     * object passed to showNotification. Additionally, the `title` property of the\n     * notification object will be used as the title.\n     *\n     * If there is no notification data in the payload then no notification will be\n     * shown.\n     */\n    SwController.prototype.onPush_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var msgPayload, hasVisibleClients, notificationDetails, notificationTitle, reg, actions, maxActions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!event.data) {\n                            return [2 /*return*/];\n                        }\n                        try {\n                            msgPayload = event.data.json();\n                        }\n                        catch (err) {\n                            // Not JSON so not an FCM message\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.hasVisibleClients_()];\n                    case 1:\n                        hasVisibleClients = _a.sent();\n                        if (hasVisibleClients) {\n                            // App in foreground. Send to page.\n                            return [2 /*return*/, this.sendMessageToWindowClients_(msgPayload)];\n                        }\n                        notificationDetails = this.getNotificationData_(msgPayload);\n                        if (!notificationDetails)\n                            return [3 /*break*/, 3];\n                        notificationTitle = notificationDetails.title || '';\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 2:\n                        reg = _a.sent();\n                        actions = notificationDetails.actions;\n                        maxActions = Notification.maxActions;\n                        // tslint:enable no-any\n                        if (actions && maxActions && actions.length > maxActions) {\n                            console.warn(\"This browser only supports \" + maxActions + \" actions.\" +\n                                \"The remaining actions will not be displayed.\");\n                        }\n                        return [2 /*return*/, reg.showNotification(notificationTitle, notificationDetails)];\n                    case 3:\n                        if (!this.bgMessageHandler)\n                            return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.bgMessageHandler(msgPayload)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SwController.prototype.onSubChange_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var registration, err_1, err_2, tokenDetailsModel, tokenDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        registration = _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        err_1 = _a.sent();\n                        throw errorFactory.create(ERROR_CODES.UNABLE_TO_RESUBSCRIBE, {\n                            message: err_1\n                        });\n                    case 3:\n                        _a.trys.push([3, 5, , 8]);\n                        return [4 /*yield*/, registration.pushManager.getSubscription()];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 8];\n                    case 5:\n                        err_2 = _a.sent();\n                        tokenDetailsModel = this.getTokenDetailsModel();\n                        return [4 /*yield*/, tokenDetailsModel.getTokenDetailsFromSWScope(registration.scope)];\n                    case 6:\n                        tokenDetails = _a.sent();\n                        if (!tokenDetails) {\n                            // This should rarely occure, but could if indexedDB\n                            // is corrupted or wiped\n                            throw err_2;\n                        }\n                        // Attempt to delete the token if we know it's bad\n                        return [4 /*yield*/, this.deleteToken(tokenDetails.fcmToken)];\n                    case 7:\n                        // Attempt to delete the token if we know it's bad\n                        _a.sent();\n                        throw err_2;\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SwController.prototype.onNotificationClick_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var msgPayload, link, windowClient, internalMsg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!event.notification ||\n                            !event.notification.data ||\n                            !event.notification.data[FCM_MSG]) {\n                            // Not an FCM notification, do nothing.\n                            return [2 /*return*/];\n                        }\n                        else if (event.action) {\n                            // User clicked on an action button.\n                            // This will allow devs to act on action button clicks by using a custom\n                            // onNotificationClick listener that they define.\n                            return [2 /*return*/];\n                        }\n                        // Prevent other listeners from receiving the event\n                        event.stopImmediatePropagation();\n                        event.notification.close();\n                        msgPayload = event.notification.data[FCM_MSG];\n                        if (!msgPayload.notification) {\n                            // Nothing to do.\n                            return [2 /*return*/];\n                        }\n                        link = (msgPayload.fcmOptions && msgPayload.fcmOptions.link) ||\n                            msgPayload.notification.click_action;\n                        if (!link) {\n                            // Nothing to do.\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.getWindowClient_(link)];\n                    case 1:\n                        windowClient = _a.sent();\n                        if (!!windowClient)\n                            return [3 /*break*/, 3];\n                        return [4 /*yield*/, self.clients.openWindow(link)];\n                    case 2:\n                        // Unable to find window client so need to open one.\n                        windowClient = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 3: return [4 /*yield*/, windowClient.focus()];\n                    case 4:\n                        windowClient = _a.sent();\n                        _a.label = 5;\n                    case 5:\n                        if (!windowClient) {\n                            // Window Client will not be returned if it's for a third party origin.\n                            return [2 /*return*/];\n                        }\n                        // Delete notification and fcmOptions data from payload before sending to\n                        // the page.\n                        delete msgPayload.notification;\n                        delete msgPayload.fcmOptions;\n                        internalMsg = createNewMsg(MessageType.NOTIFICATION_CLICKED, msgPayload);\n                        // Attempt to send a message to the client to handle the data\n                        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n                        return [2 /*return*/, this.attemptToMessageClient_(windowClient, internalMsg)];\n                }\n            });\n        });\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.getNotificationData_ = function (msgPayload) {\n        if (!msgPayload) {\n            return;\n        }\n        if (typeof msgPayload.notification !== 'object') {\n            return;\n        }\n        var notificationInformation = __assign({}, msgPayload.notification);\n        // Put the message payload under FCM_MSG name so we can identify the\n        // notification as being an FCM notification vs a notification from\n        // somewhere else (i.e. normal web push or developer generated\n        // notification).\n        notificationInformation.data = __assign({}, msgPayload.notification.data, (_a = {}, _a[FCM_MSG] = msgPayload, _a));\n        return notificationInformation;\n        var _a;\n    };\n    /**\n     * Calling setBackgroundMessageHandler will opt in to some specific\n     * behaviours.\n     * 1.) If a notification doesn't need to be shown due to a window already\n     * being visible, then push messages will be sent to the page.\n     * 2.) If a notification needs to be shown, and the message contains no\n     * notification data this method will be called\n     * and the promise it returns will be passed to event.waitUntil.\n     * If you do not set this callback then all push messages will let and the\n     * developer can handle them in a their own 'push' event callback\n     *\n     * @param callback The callback to be called when a push message is received\n     * and a notification must be shown. The callback will be given the data from\n     * the push message.\n     */\n    SwController.prototype.setBackgroundMessageHandler = function (callback) {\n        if (!callback || typeof callback !== 'function') {\n            throw errorFactory.create(ERROR_CODES.BG_HANDLER_FUNCTION_EXPECTED);\n        }\n        this.bgMessageHandler = callback;\n    };\n    /**\n     * @param url The URL to look for when focusing a client.\n     * @return Returns an existing window client or a newly opened WindowClient.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.getWindowClient_ = function (url) {\n        return __awaiter(this, void 0, void 0, function () {\n            var parsedURL, clientList, suitableClient, i, parsedClientUrl;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        parsedURL = new URL(url, self.location.href).href;\n                        return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        suitableClient = null;\n                        for (i = 0; i < clientList.length; i++) {\n                            parsedClientUrl = new URL(clientList[i].url, self.location.href)\n                                .href;\n                            if (parsedClientUrl === parsedURL) {\n                                suitableClient = clientList[i];\n                                break;\n                            }\n                        }\n                        return [2 /*return*/, suitableClient];\n                }\n            });\n        });\n    };\n    /**\n     * This message will attempt to send the message to a window client.\n     * @param client The WindowClient to send the message to.\n     * @param message The message to send to the client.\n     * @returns Returns a promise that resolves after sending the message. This\n     * does not guarantee that the message was successfully received.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.attemptToMessageClient_ = function (client, message) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                // NOTE: This returns a promise in case this API is abstracted later on to\n                // do additional work\n                if (!client) {\n                    throw errorFactory.create(ERROR_CODES.NO_WINDOW_CLIENT_TO_MSG);\n                }\n                client.postMessage(message);\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * @returns If there is currently a visible WindowClient, this method will\n     * resolve to true, otherwise false.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.hasVisibleClients_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var clientList;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        return [2 /*return*/, clientList.some(function (client) { return client.visibilityState === 'visible'; })];\n                }\n            });\n        });\n    };\n    /**\n     * @param msgPayload The data from the push event that should be sent to all\n     * available pages.\n     * @returns Returns a promise that resolves once the message has been sent to\n     * all WindowClients.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var clientList, internalMsg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);\n                        return [4 /*yield*/, Promise.all(clientList.map(function (client) {\n                                return _this.attemptToMessageClient_(client, internalMsg);\n                            }))];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This will register the default service worker and return the registration.\n     * @return he service worker registration to be used for the push service.\n     */\n    SwController.prototype.getSWRegistration_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, self.registration];\n            });\n        });\n    };\n    /**\n     * This will return the default VAPID key or the uint8array version of the\n     * public VAPID key provided by the developer.\n     */\n    SwController.prototype.getPublicVapidKey_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var swReg, vapidKeyFromDatabase;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        swReg = _a.sent();\n                        if (!swReg) {\n                            throw errorFactory.create(ERROR_CODES.SW_REGISTRATION_EXPECTED);\n                        }\n                        return [4 /*yield*/, this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope)];\n                    case 2:\n                        vapidKeyFromDatabase = _a.sent();\n                        if (vapidKeyFromDatabase == null) {\n                            return [2 /*return*/, DEFAULT_PUBLIC_VAPID_KEY];\n                        }\n                        return [2 /*return*/, vapidKeyFromDatabase];\n                }\n            });\n        });\n    };\n    return SwController;\n}(BaseController));\nfunction getClientList() {\n    return self.clients.matchAll({\n        type: 'window',\n        includeUncontrolled: true\n        // TS doesn't know that \"type: 'window'\" means it'll return WindowClient[]\n    });\n}\nfunction createNewMsg(msgType, msgData) {\n    return _a = {}, _a[MessageParameter.TYPE_OF_MSG] = msgType, _a[MessageParameter.DATA] = msgData, _a;\n    var _a;\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_SW_PATH = '/firebase-messaging-sw.js';\nvar DEFAULT_SW_SCOPE = '/firebase-cloud-messaging-push-scope';\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar WindowController = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(WindowController, _super);\n    /**\n     * A service that provides a MessagingService instance.\n     */\n    function WindowController(app) {\n        var _this = _super.call(this, app) || this;\n        _this.registrationToUse = null;\n        _this.publicVapidKeyToUse = null;\n        _this.manifestCheckPromise = null;\n        _this.messageObserver = null;\n        // @ts-ignore: Unused variable error, this is not implemented yet.\n        _this.tokenRefreshObserver = null;\n        _this.onMessageInternal = createSubscribe(function (observer) {\n            _this.messageObserver = observer;\n        });\n        _this.onTokenRefreshInternal = createSubscribe(function (observer) {\n            _this.tokenRefreshObserver = observer;\n        });\n        _this.setupSWMessageListener_();\n        return _this;\n    }\n    /**\n     * This method returns an FCM token if it can be generated.\n     * The return promise will reject if the browser doesn't support\n     * FCM, if permission is denied for notifications or it's not\n     * possible to generate a token.\n     *\n     * @return Returns a promise that resolves to an FCM token or null if\n     * permission isn't granted.\n     */\n    WindowController.prototype.getToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.manifestCheckPromise) {\n                            this.manifestCheckPromise = manifestCheck();\n                        }\n                        return [4 /*yield*/, this.manifestCheckPromise];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, _super.prototype.getToken.call(this)];\n                }\n            });\n        });\n    };\n    /**\n     * Request permission if it is not currently granted\n     *\n     * @return Resolves if the permission was granted, otherwise rejects\n     */\n    WindowController.prototype.requestPermission = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var permissionResult;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.getNotificationPermission_() === 'granted') {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, Notification.requestPermission()];\n                    case 1:\n                        permissionResult = _a.sent();\n                        if (permissionResult === 'granted') {\n                            return [2 /*return*/];\n                        }\n                        else if (permissionResult === 'denied') {\n                            throw errorFactory.create(ERROR_CODES.PERMISSION_BLOCKED);\n                        }\n                        else {\n                            throw errorFactory.create(ERROR_CODES.PERMISSION_DEFAULT);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This method allows a developer to override the default service worker and\n     * instead use a custom service worker.\n     *\n     * @param registration The service worker registration that should be used to\n     * receive the push messages.\n     */\n    WindowController.prototype.useServiceWorker = function (registration) {\n        if (!(registration instanceof ServiceWorkerRegistration)) {\n            throw errorFactory.create(ERROR_CODES.SW_REGISTRATION_EXPECTED);\n        }\n        if (this.registrationToUse != null) {\n            throw errorFactory.create(ERROR_CODES.USE_SW_BEFORE_GET_TOKEN);\n        }\n        this.registrationToUse = registration;\n    };\n    /**\n     * This method allows a developer to override the default vapid key\n     * and instead use a custom VAPID public key.\n     *\n     * @param publicKey A URL safe base64 encoded string.\n     */\n    WindowController.prototype.usePublicVapidKey = function (publicKey) {\n        if (typeof publicKey !== 'string') {\n            throw errorFactory.create(ERROR_CODES.INVALID_PUBLIC_VAPID_KEY);\n        }\n        if (this.publicVapidKeyToUse != null) {\n            throw errorFactory.create(ERROR_CODES.USE_PUBLIC_KEY_BEFORE_GET_TOKEN);\n        }\n        var parsedKey = base64ToArrayBuffer(publicKey);\n        if (parsedKey.length !== 65) {\n            throw errorFactory.create(ERROR_CODES.PUBLIC_KEY_DECRYPTION_FAILED);\n        }\n        this.publicVapidKeyToUse = parsedKey;\n    };\n    /**\n     * @export\n     * @param nextOrObserver An observer object or a function triggered on\n     * message.\n     * @param error A function triggered on message error.\n     * @param completed function triggered when the observer is removed.\n     * @return The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onMessage = function (nextOrObserver, error, completed) {\n        if (typeof nextOrObserver === 'function') {\n            return this.onMessageInternal(nextOrObserver, error, completed);\n        }\n        else {\n            return this.onMessageInternal(nextOrObserver);\n        }\n    };\n    /**\n     * @param nextOrObserver An observer object or a function triggered on token\n     * refresh.\n     * @param error A function triggered on token refresh error.\n     * @param completed function triggered when the observer is removed.\n     * @return The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onTokenRefresh = function (nextOrObserver, error, completed) {\n        if (typeof nextOrObserver === 'function') {\n            return this.onTokenRefreshInternal(nextOrObserver, error, completed);\n        }\n        else {\n            return this.onTokenRefreshInternal(nextOrObserver);\n        }\n    };\n    /**\n     * Given a registration, wait for the service worker it relates to\n     * become activer\n     * @param registration Registration to wait for service worker to become active\n     * @return Wait for service worker registration to become active\n     */\n    // Visible for testing\n    // TODO: Make private\n    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n        var serviceWorker = registration.installing || registration.waiting || registration.active;\n        return new Promise(function (resolve, reject) {\n            if (!serviceWorker) {\n                // This is a rare scenario but has occured in firefox\n                reject(errorFactory.create(ERROR_CODES.NO_SW_IN_REG));\n                return;\n            }\n            // Because the Promise function is called on next tick there is a\n            // small chance that the worker became active or redundant already.\n            if (serviceWorker.state === 'activated') {\n                resolve(registration);\n                return;\n            }\n            if (serviceWorker.state === 'redundant') {\n                reject(errorFactory.create(ERROR_CODES.SW_REG_REDUNDANT));\n                return;\n            }\n            var stateChangeListener = function () {\n                if (serviceWorker.state === 'activated') {\n                    resolve(registration);\n                }\n                else if (serviceWorker.state === 'redundant') {\n                    reject(errorFactory.create(ERROR_CODES.SW_REG_REDUNDANT));\n                }\n                else {\n                    // Return early and wait to next state change\n                    return;\n                }\n                serviceWorker.removeEventListener('statechange', stateChangeListener);\n            };\n            serviceWorker.addEventListener('statechange', stateChangeListener);\n        });\n    };\n    /**\n     * This will register the default service worker and return the registration\n     * @return The service worker registration to be used for the push service.\n     */\n    WindowController.prototype.getSWRegistration_ = function () {\n        var _this = this;\n        if (this.registrationToUse) {\n            return this.waitForRegistrationToActivate_(this.registrationToUse);\n        }\n        // Make the registration null so we know useServiceWorker will not\n        // use a new service worker as registrationToUse is no longer undefined\n        this.registrationToUse = null;\n        return navigator.serviceWorker\n            .register(DEFAULT_SW_PATH, {\n            scope: DEFAULT_SW_SCOPE\n        })\n            .catch(function (err) {\n            throw errorFactory.create(ERROR_CODES.FAILED_DEFAULT_REGISTRATION, {\n                browserErrorMessage: err.message\n            });\n        })\n            .then(function (registration) {\n            return _this.waitForRegistrationToActivate_(registration).then(function () {\n                _this.registrationToUse = registration;\n                // We update after activation due to an issue with Firefox v49 where\n                // a race condition occassionally causes the service work to not\n                // install\n                registration.update();\n                return registration;\n            });\n        });\n    };\n    /**\n     * This will return the default VAPID key or the uint8array version of the public VAPID key\n     * provided by the developer.\n     */\n    WindowController.prototype.getPublicVapidKey_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.publicVapidKeyToUse) {\n                    return [2 /*return*/, this.publicVapidKeyToUse];\n                }\n                return [2 /*return*/, DEFAULT_PUBLIC_VAPID_KEY];\n            });\n        });\n    };\n    /**\n     * This method will set up a message listener to handle\n     * events from the service worker that should trigger\n     * events in the page.\n     */\n    // Visible for testing\n    // TODO: Make private\n    WindowController.prototype.setupSWMessageListener_ = function () {\n        var _this = this;\n        navigator.serviceWorker.addEventListener('message', function (event) {\n            if (!event.data || !event.data[MessageParameter.TYPE_OF_MSG]) {\n                // Not a message from FCM\n                return;\n            }\n            var workerPageMessage = event.data;\n            switch (workerPageMessage[MessageParameter.TYPE_OF_MSG]) {\n                case MessageType.PUSH_MSG_RECEIVED:\n                case MessageType.NOTIFICATION_CLICKED:\n                    var pushMessage = workerPageMessage[MessageParameter.DATA];\n                    if (_this.messageObserver) {\n                        _this.messageObserver.next(pushMessage);\n                    }\n                    break;\n                default:\n                    // Noop.\n                    break;\n            }\n        }, false);\n    };\n    return WindowController;\n}(BaseController));\n/**\n * The method checks that a manifest is defined and has the correct GCM\n * sender ID.\n * @return Returns a promise that resolves if the manifest matches\n * our required sender ID\n */\n// Exported for testing\nfunction manifestCheck() {\n    return __awaiter(this, void 0, void 0, function () {\n        var manifestTag, manifestContent, response, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    manifestTag = document.querySelector('link[rel=\"manifest\"]');\n                    if (!manifestTag) {\n                        return [2 /*return*/];\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 4, , 5]);\n                    return [4 /*yield*/, fetch(manifestTag.href)];\n                case 2:\n                    response = _a.sent();\n                    return [4 /*yield*/, response.json()];\n                case 3:\n                    manifestContent = _a.sent();\n                    return [3 /*break*/, 5];\n                case 4:\n                    e_1 = _a.sent();\n                    // If the download or parsing fails allow check.\n                    // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n                    return [2 /*return*/];\n                case 5:\n                    if (!manifestContent || !manifestContent.gcm_sender_id) {\n                        return [2 /*return*/];\n                    }\n                    if (manifestContent.gcm_sender_id !== '103953800507') {\n                        throw errorFactory.create(ERROR_CODES.INCORRECT_GCM_SENDER_ID);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerMessaging(instance) {\n    var messagingName = 'messaging';\n    var factoryMethod = function (app) {\n        if (!isSupported()) {\n            throw errorFactory.create(ERROR_CODES.UNSUPPORTED_BROWSER);\n        }\n        if (self && 'ServiceWorkerGlobalScope' in self) {\n            // Running in ServiceWorker context\n            return new SwController(app);\n        }\n        else {\n            // Assume we are in the window context.\n            return new WindowController(app);\n        }\n    };\n    var namespaceExports = {\n        isSupported: isSupported\n    };\n    instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);\n}\nregisterMessaging(firebase);\nfunction isSupported() {\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n        // Running in ServiceWorker context\n        return isSWControllerSupported();\n    }\n    else {\n        // Assume we are in the window context.\n        return isWindowControllerSupported();\n    }\n}\n/**\n * Checks to see if the required APIs exist.\n */\nfunction isWindowControllerSupported() {\n    return (navigator.cookieEnabled &&\n        'serviceWorker' in navigator &&\n        'PushManager' in window &&\n        'Notification' in window &&\n        'fetch' in window &&\n        ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n        PushSubscription.prototype.hasOwnProperty('getKey'));\n}\n/**\n * Checks to see if the required APIs exist within SW Context.\n */\nfunction isSWControllerSupported() {\n    return ('PushManager' in self &&\n        'Notification' in self &&\n        ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n        PushSubscription.prototype.hasOwnProperty('getKey'));\n}\nexport { registerMessaging, isSupported };\n",null]}